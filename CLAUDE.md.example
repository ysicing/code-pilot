# CLAUDE.md

## Language Configuration

**IMPORTANT**: Always respond and communicate in Chinese (中文) for all interactions, explanations, and communications with the user. This applies to:
- All responses and explanations
- Error messages and status updates
- Progress reports and task summaries
- Code comments when requested
- Documentation when created

The agent configurations and command prompts should remain in their original language to ensure proper functionality.

---

本文件为 Claude Code (claude.ai/code) 在此代码仓库中工作时提供指导。

## 项目概述

这是一个 Claude Code 多智能体工作流系统，提供了一个**轻量级元框架**，用于实现自动化的专家开发工作流。它将手动命令链转换为具有实用质量门禁和专业化技能的自动化多智能体流程。

**核心理念**：质量门禁自动化 + 专业化分工 + 轻量级流程

## 架构

### 核心组件

系统提供：

1. **Commands（命令）** - 10个专门化命令（1个主要 + 9个手动），用于目标导向的开发工作流
2. **Agents（智能体）** - 9个专家智能体配置，用于多智能体编排（4个需求工作流 + 5个专门化）

### 关键工作流模式

**需求驱动工作流**（主要）：
```
requirements-generate → requirements-code → requirements-review → (✅ Ready?) → smart-testing-decision
```

## 命令概览

### 主要命令：`/requirements-pilot`
具有智能适配能力的主要自动化工作流命令：

**用法**：
```bash
/requirements-pilot <FEATURE_DESCRIPTION> [--test|--no-test]
```

**核心功能**：
- 交互式需求确认，配备100分质量评估
- 90+质量分数的用户审批门禁（强制停止点）
- 4阶段自动化实施：需求 → 规范 → 代码 → 测试
- 智能测试决策，支持UI感知策略
- 文件结构管理（.claude/specs/{feature_name}/）

### 手动命令（共9个）

- `/ask <TECHNICAL_QUESTION>` - 高级系统架构师，采用4专家咨询方法论
- `/story-breakdown <FEATURE_DESCRIPTION>` - 将复杂功能分解为可实施的用户故事
- `/bugfix <ERROR_DESCRIPTION>` - 缺陷解决工作流，配备系统化分析
- `/code <FEATURE_DESCRIPTION>` - 直接功能实现
- `/debug <TASK_DESCRIPTION>` - UltraThink 调试编排器，4阶段系统化分析
- `/optimize <PERFORMANCE_TARGET>` - 性能优化
- `/review <CODE_SCOPE>` - 多维度代码审查（质量、安全、性能、架构）
- `/test <COMPONENT_OR_FEATURE>` - 测试策略和实施
- `/release-check <COMPONENT_OR_SYSTEM>` - 生产就绪验证，包含通过/不通过决策

## 智能体架构

### 需求工作流智能体
- **requirements-generate**：面向代码生成优化的技术规范，具有直接实现映射
- **requirements-code**：直接实现，最小架构开销
- **requirements-review**：实用性评审，专注功能而非架构完美（3级评分）
- **requirements-testing**：智能测试，比例覆盖和UI感知策略，防止过度测试

### 专门化智能体
- **bugfix**：缺陷解决专家，用于系统化缺陷分析和修复
- **bugfix-verify**：独立修复验证和客观评估
- **code**：开发协调员，指导编码专家
- **debug**：UltraThink 调试编排器，用于系统化问题分析和多智能体协调
- **optimize**：性能优化协调员

## 质量门禁系统

### 质量标准
- **需求清晰度**：实施开始前90+分
- **代码质量**：测试阶段前90+分
- **生产就绪度**：发布时明确的通过/不通过决策

## 工作流指南

### 多智能体协调
- 每个智能体在隔离环境中操作，防止质量下降
- 自动质量门禁决定工作流进展
- 大多数质量门禁的90+质量分数阈值
- 未达到质量阈值时的迭代改进循环

### 智能测试策略
- **仅UI变更**：纯UI变更（颜色、布局、文本）仅进行Lint检查
- **轻微变更（1-5行）**：比例测试，仅进行Lint检查
- **业务逻辑**：基于风险的全面测试覆盖
- **复杂功能**：完整测试金字塔方法

**测试决策逻辑**：
- **默认**：审查通过后问 "代码完成。运行测试吗？ (y/n)"
- **--test**：审查成功后自动运行测试
- **--no-test**：完全跳过测试
- **组件识别**：前端UI和后端逻辑采用不同策略

### 实现优先方法
- 面向代码生成优化的直接技术规范
- 最小化架构抽象
- 规范的单文档策略
- 具体实现细节优于理论设计

## 阶段化工具使用

### 📋 需求分析 → `/story-breakdown`
将复杂功能分解为具有明确验收标准的可实现用户故事。

### 🏛️ 架构设计 → `/ask`  
在实施前进行技术决策的多专家咨询。

### ⚡ 实现 → `/requirements-pilot`（推荐）或 `/code`
基于复杂度的自动化流水线或直接实现。

### 🧪 测试 → `/test` 
具有比例覆盖的智能测试策略。

### 🔍 质量保障 → `/review`
90+质量分数阈值的多维度代码审查。

### 🐛 问题解决 → `/debug` 或 `/bugfix`
- `/debug`：UltraThink系统化调试，包含用户确认门禁
- `/bugfix`：具有系统化分析的缺陷解决工作流

### ⚡ 性能优化 → `/optimize`
针对特定目标和瓶颈的性能优化。

### 🚀 发布准备 → `/release-check`
具有明确通过/不通过决策的生产就绪验证。

## 文件结构约定

### 规范目录（针对 `/requirements-pilot` 工作流）
- `.claude/specs/{feature_name}/` - 使用 `/requirements-pilot` 时自动创建
- `requirements-confirm.md` - 需求确认过程和最终需求
- `requirements-spec.md` - 技术实现规范

**注意**：此目录结构仅在使用 `/requirements-pilot` 自动化工作流时创建。

## 核心原则

系统遵循：
- **KISS** (Keep It Simple, Stupid)
- **YAGNI** (You Ain't Gonna Need It)  
- **SOLID** 原则
- **质量门禁自动化**：客观标准优于主观判断
- **专业化分工**：每个工具专注一个领域
- **轻量化流程**：无官僚主义的必要工作流步骤

专注于具有自动化质量保障的实用、可工作解决方案。

## 开发指南

### 内容和沟通
- **文件优先级**：始终优先编辑现有文件而非创建新文件
- **文档**：除非明确要求，否则不主动创建文档文件
- **验证**：始终独立验证信息来源
- **风格**：专业语调下的清晰、简洁沟通
- **标点**：代码中使用英文标点，文档中匹配文档语言
- **Emoji使用**：仅用于章节导航，避免在代码和沟通中使用

### 任务完成标准
当主要目标实现时，任务即被认为完成。当无法完全完成时：

**部分执行策略**：
- 首先执行所有可行组件
- 清晰记录剩余问题和阻塞因素
- 提供具体的下一步解决方案

**替代解决方案（当任务无法执行时）**：
- 提供至少3种替代方法来实现相同目标
- 解释每种替代方案的权衡和建议
- 必要时建议修改范围或需求

**完成禁止事项**：
如果存在以下任一情况，绝不认为任务已完成：
- 关键功能损坏或无法正常工作
- 响应中明确列出影响核心功能的具体剩余工作项

### 代码质量标准
遵循“保持简单”原则：
- **避免过度抽象**：保持实现实用和直接
- **单一职责**：遵循单一职责原则
- **代码复用**：通过提取公共功能来消除重复代码
- **一致命名**：采用统一的命名约定
- **错误处理**：实现一致的错误处理模式
- **无硬编码**：使用配置或常量而非硬编码值

**平衡原则**：仅在能减少复杂性时才应用自动化和抽象。

### 持续改进
- 从代码模式中学习并一致地应用最佳实践
- 将用户反馈融入实现方法
- 根据项目特定需求更新实践
