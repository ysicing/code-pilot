---
description: 通过提出最多5个高度针对性的澄清问题来识别当前功能规格中未充分指定的区域，并将答案编码回规格中。
---

用户输入可以由代理直接提供或作为命令参数提供 - 在继续执行提示之前，你**必须**考虑它（如果非空）。

用户输入：

$ARGUMENTS

目标：检测并减少活动功能规格中的歧义或缺失的决策点，并将澄清内容直接记录在规格文件中。

注意：此澄清工作流程预期在调用 `/spec-kit:plan` 之前运行（并完成）。如果用户明确说明他们正在跳过澄清（例如，探索性尖峰），你可以继续，但必须警告下游返工风险增加。

执行步骤：

1. 在仓库根目录运行**一次** `~/.claude/scripts/specify/check-prerequisites.sh --json --paths-only`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选捕获 `IMPL_PLAN`、`TASKS` 用于未来的链式流程。）
   - 如果 JSON 解析失败，中止并指导用户重新运行 `/spec-kit:specify` 或验证功能分支环境。

2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰/部分/缺失。生成用于优先级排序的内部覆盖图（除非不会提出问题，否则不输出原始图）。

   功能范围与行为：
   - 核心用户目标和成功标准
   - 明确的范围外声明
   - 用户角色/角色区分

   领域与数据模型：
   - 实体、属性、关系
   - 身份与唯一性规则
   - 生命周期/状态转换
   - 数据量/规模假设

   交互与用户体验流程：
   - 关键用户旅程/序列
   - 错误/空/加载状态
   - 可访问性或本地化说明

   非功能质量属性：
   - 性能（延迟、吞吐量目标）
   - 可扩展性（横向/纵向、限制）
   - 可靠性与可用性（正常运行时间、恢复期望）
   - 可观察性（日志、指标、跟踪信号）
   - 安全与隐私（认证/授权、数据保护、威胁假设）
   - 合规/监管约束（如有）

   集成与外部依赖：
   - 外部服务/API 和故障模式
   - 数据导入/导出格式
   - 协议/版本假设

   边缘情况与故障处理：
   - 负面场景
   - 速率限制/节流
   - 冲突解决（例如，并发编辑）

   约束与权衡：
   - 技术约束（语言、存储、托管）
   - 明确的权衡或被拒绝的替代方案

   术语与一致性：
   - 规范化术语表术语
   - 避免的同义词/弃用术语

   完成信号：
   - 验收标准可测试性
   - 可衡量的完成定义风格指标

   杂项/占位符：
   - TODO 标记/未解决的决策
   - 缺乏量化的歧义形容词（"强健"、"直观"）

   对于每个状态为部分或缺失的类别，添加候选问题机会，除非：
   - 澄清不会实质性改变实施或验证策略
   - 信息最好推迟到规划阶段（内部注释）

3. 生成（内部）候选澄清问题的优先级队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：
   - 整个会话中总共最多 5 个问题。
   - 每个问题必须能够通过以下任一方式回答：
     * 简短的多项选择（2-5 个不同的、互斥的选项），或
     * 一个词/简短短语答案（明确限制："回答不超过 5 个词"）。
   - 只包括答案会实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规验证的问题。
   - 确保类别覆盖平衡：首先尝试覆盖影响最大的未解决类别；避免在单个高影响区域（例如，安全态势）未解决时提出两个低影响问题。
   - 排除已回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。
   - 优先选择减少下游返工风险或防止不一致验收测试的澄清。
   - 如果超过 5 个类别仍未解决，通过（影响 * 不确定性）启发式选择前 5 个。

4. 顺序提问循环（交互式）：
   - 一次只提出一个问题。
   - 对于多选题，将选项呈现为 Markdown 表格：

     | 选项 | 描述 |
     |-----|------|
     | A | <选项 A 描述> |
     | B | <选项 B 描述> |
     | C | <选项 C 描述> | （根据需要添加 D/E，最多 5 个）
     | 简答 | 提供不同的简短答案（<=5 个词）| （仅在适合自由形式替代时包含）

   - 对于简答风格（没有有意义的离散选项），在问题后输出单行：`格式：简短答案（<=5 个词）`。
   - 用户回答后：
     * 验证答案映射到一个选项或符合 <=5 个词的约束。
     * 如果模棱两可，要求快速消歧（仍属于同一问题；不前进）。
     * 一旦满意，将其记录在工作记忆中（尚未写入磁盘）并转到下一个排队的问题。
   - 在以下情况下停止提出进一步的问题：
     * 所有关键歧义早期解决（剩余的排队项变得不必要），或
     * 用户发出完成信号（"完成"、"好的"、"不再有"），或
     * 你达到 5 个已提问题。
   - 永远不要提前透露未来排队的问题。
   - 如果开始时不存在有效问题，立即报告没有关键歧义。

5. 每个接受的答案后的集成（增量更新方法）：
   - 维护规格的内存表示（在开始时加载一次）加上原始文件内容。
   - 对于此会话中第一个集成的答案：
     * 确保存在 `## 澄清` 部分（如果缺失，根据规格模板在最高级别的上下文/概述部分之后创建它）。
     * 在其下，为今天创建（如果不存在）`### 会话 YYYY-MM-DD` 子标题。
   - 接受后立即追加一个要点行：`- 问：<问题> → 答：<最终答案>`。
   - 然后立即将澄清应用到最合适的部分：
     * 功能歧义 → 在功能需求中更新或添加要点。
     * 用户交互/参与者区分 → 使用澄清的角色、约束或场景更新用户故事或参与者子部分（如果存在）。
     * 数据形状/实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地注明添加的约束。
     * 非功能约束 → 在非功能/质量属性部分添加/修改可衡量的标准（将模糊形容词转换为指标或明确目标）。
     * 边缘情况/负面流程 → 在边缘情况/错误处理下添加新要点（或创建此子部分，如果模板为其提供占位符）。
     * 术语冲突 → 在规格中规范化术语；仅在必要时保留原始术语，添加一次 `（以前称为"X"）`。
   - 如果澄清使早期模糊的声明无效，替换该声明而不是重复；不留下过时的矛盾文本。
   - 在每次集成后保存规格文件以最小化上下文丢失的风险（原子覆盖）。
   - 保留格式：不重新排序不相关的部分；保持标题层次结构不变。
   - 保持每个插入的澄清最小和可测试（避免叙述漂移）。

6. 验证（在每次写入后加上最终通过后执行）：
   - 澄清会话每个接受的答案恰好包含一个要点（无重复）。
   - 总提问（接受）问题 ≤ 5。
   - 更新的部分不包含新答案旨在解决的挥之不去的模糊占位符。
   - 没有矛盾的早期声明仍然存在（扫描现已删除的无效替代选择）。
   - Markdown 结构有效；仅允许的新标题：`## 澄清`、`### 会话 YYYY-MM-DD`。
   - 术语一致性：在所有更新的部分中使用相同的规范术语。

7. 将更新的规格写回 `FEATURE_SPEC`。

8. 报告完成（提问循环结束或提前终止后）：
   - 提问和回答的问题数量。
   - 更新规格的路径。
   - 涉及的部分（列出名称）。
   - 覆盖摘要表，列出每个分类法类别及状态：已解决（原为部分/缺失并已处理）、推迟（超出问题配额或更适合规划）、清晰（已经足够）、未解决（仍为部分/缺失但影响较低）。
   - 如果仍有任何未解决或推迟，建议是否继续 `/spec-kit:plan` 或稍后在计划后再次运行 `/spec-kit:clarify`。
   - 建议的下一个命令。

行为规则：
- 如果没有发现有意义的歧义（或所有潜在问题都是低影响的），回应："未检测到值得正式澄清的关键歧义。"并建议继续。
- 如果规格文件缺失，指导用户先运行 `/spec-kit:specify`（不要在此处创建新规格）。
- 永远不要超过总共 5 个提问（对单个问题的澄清重试不算作新问题）。
- 避免推测性的技术栈问题，除非缺失会阻碍功能清晰度。
- 尊重用户提前终止信号（"停止"、"完成"、"继续"）。
- 如果由于完全覆盖而没有提问，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。
- 如果配额用完但仍有未解决的高影响类别，明确在推迟下标记它们并说明理由。

优先级上下文：$ARGUMENTS
