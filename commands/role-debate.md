---
description: 专业角色间深度辩论和技术选型讨论，通过结构化辩论解决分歧
argument-hint: <角色1> vs <角色2> [主题]
---

# 角色辩论

专业角色间的深度辩论和技术选型讨论，通过结构化辩论解决专业分歧。

## 使用方法

```bash
/role-debate <角色1> vs <角色2> [主题]
/role-debate <角色1>,<角色2> vs <角色3>,<角色4> [主题]
```

## 核心特性

- **对立观点展示**：清晰展示不同专业角色的观点分歧
- **深度论证过程**：每个角色提供详细的专业依据
- **交锋式讨论**：模拟真实的技术团队讨论过程
- **收敛式结论**：基于辩论过程得出平衡的技术决策

## 适用场景

### ✅ 使用 Role-debate 的情况
- 技术架构选型存在明显权衡（如单体 vs 微服务）
- 性能与安全之间的平衡选择
- 前端框架、数据库技术的选型讨论
- 开发效率与代码质量的权衡
- 成本预算与技术先进性的取舍

### ❌ 不适合 Role-debate 的情况
- 没有明显分歧的技术问题（使用 multi-role）
- 单纯的bug修复或功能实现（使用 bugfix 或 code）
- 需要综合评估而非对立讨论（使用 multi-role）

## 基本示例

```bash
# 架构选型辩论
/role-debate architect vs performance
"单体架构 vs 微服务架构的选择"

# 安全与性能的权衡
/role-debate security vs performance  
"API 认证机制：JWT vs Session 的选择"

# 前端技术选型
/role-debate frontend vs performance
"React vs Vue.js 的性能表现对比"

# 团队对抗辩论（2v2）
/role-debate architect,security vs performance,qa
"是否应该采用容器化部署策略"
```

## 辩论流程

### 阶段 1：开题立论（3分钟）
**正方观点**：
- 核心论点阐述
- 关键优势说明
- 支持性数据展示

**反方观点**：
- 对立观点提出
- 潜在问题指出
- 反驳性证据展示

### 阶段 2：交叉质辩（5分钟）
**攻辩环节**：
- 针对对方弱点质疑
- 提供具体反例
- 挑战假设条件

**应辩环节**：
- 回应对方质疑
- 提供补充证据
- 澄清误解和偏见

### 阶段 3：总结陈词（2分钟）
**最终立场**：
- 重申核心观点
- 总结辩论优势
- 提出妥协方案

### 阶段 4：裁决分析
**客观评估**：
- 分析双方论点强度
- 识别关键决策因素
- 提供平衡的建议方案

## 输出格式示例

### 单对单辩论格式

```markdown
角色辩论：Architect vs Performance
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
辩题：微服务架构 vs 单体架构的选择

## 开题立论

### 🏛️ Architect（正方）：微服务架构
**核心论点**：微服务架构提供更好的可维护性和团队协作
- **模块化设计**：每个服务独立开发、部署、扩展
- **技术多样性**：不同服务可选择最适合的技术栈
- **团队自治**：减少团队间的依赖和冲突
- **容错隔离**：单个服务故障不影响整体系统

**关键数据**：Netflix、Amazon等大规模系统成功案例

### ⚡ Performance（反方）：单体架构  
**核心论点**：单体架构在性能和运维上更具优势
- **网络开销**：避免服务间网络调用的延迟损失
- **事务一致性**：本地事务比分布式事务更可靠
- **部署简单**：单一部署单元，运维复杂度低
- **性能监控**：更容易进行性能分析和优化

**关键数据**：微服务平均增加15-30%的网络延迟

## 交叉质辩

### 🏛️ Architect 质疑
**Q**: "单体架构如何处理不同模块的性能要求差异？"
**A**: Performance 回应："通过代码层面的优化和缓存策略可以解决"

### ⚡ Performance 质疑  
**Q**: "微服务的网络延迟如何保证用户体验？"
**A**: Architect 回应："通过异步处理和智能缓存可以优化用户感知"

### 🏛️ Architect 追问
**Q**: "单体架构在团队规模扩大时如何避免开发冲突？"
**A**: Performance 承认："这确实是单体架构的挑战点"

### ⚡ Performance 追问
**Q**: "分布式事务失败如何保证数据一致性？"  
**A**: Architect 回应："采用 Saga 模式或事件溯源可以解决"

## 总结陈词

### 🏛️ Architect 总结
"微服务架构虽然增加了系统复杂度，但为长期可维护性和团队扩展提供了必要基础。在当前业务快速发展阶段，这种前期投入是值得的。"

### ⚡ Performance 总结
"单体架构在性能和运维上的优势不容忽视。除非团队规模和业务复杂度达到一定程度，否则微服务的收益可能无法抵消其成本。"

## 裁决分析

### 关键决策因素
1. **团队规模**：10人以下建议单体，20人以上考虑微服务
2. **业务复杂度**：模块间耦合度决定架构选择  
3. **性能要求**：高并发场景下微服务优势明显
4. **运维能力**：需要评估团队的DevOps成熟度

### 平衡建议方案
**阶段性演进策略**：
1. **第一阶段（6个月）**：采用模块化单体架构
2. **第二阶段（12个月）**：识别独立业务域，准备服务拆分
3. **第三阶段（18个月）**：逐步迁移到微服务架构

**核心权衡**：在开发效率和长期可扩展性之间找平衡

### 最终建议
✅ **推荐方案**：模块化单体 → 逐步演进微服务  
⚠️ **风险控制**：充分的监控和回滚策略  
📊 **成功指标**：开发效率、系统性能、运维成本综合评估
```

### 团队对抗辩论格式

```markdown
角色辩论：Architect + Security vs Performance + QA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
辩题：是否应该采用容器化部署策略

## 正方阵营：Architect + Security

### 🏛️ Architect 立论
**容器化的架构优势**：
- 环境一致性解决"在我机器上可以运行"问题
- 资源利用率比传统虚拟机提高 60-80%
- 支持蓝绿部署、灰度发布等现代部署模式

### 🔒 Security 补充
**安全性增强措施**：
- 镜像层安全扫描，及时发现漏洞
- 运行时隔离减少攻击面
- 不可变基础设施提高安全可控性

## 反方阵营：Performance + QA

### ⚡ Performance 立论  
**性能方面的担忧**：
- 容器化增加 5-15% 的性能开销
- 网络虚拟化导致额外的延迟
- 存储 I/O 性能不如直接部署

### ✅ QA 补充
**质量保证的挑战**：  
- 容器环境的测试复杂度增加
- 调试和性能分析工具适配问题
- 生产环境问题的本地重现困难

## 激烈交锋

### 正方攻击
🏛️ **Architect**: "传统部署的环境差异问题如何解决？"
⚡ **Performance**: "通过标准化配置管理和自动化脚本可以解决"

🔒 **Security**: "裸金属部署如何快速应对安全漏洞？"
✅ **QA**: "建立完善的补丁管理流程和应急响应机制"

### 反方反击
⚡ **Performance**: "容器化的性能损失如何向业务方解释？"
🏛️ **Architect**: "通过更高的资源利用率，总体成本实际降低"

✅ **QA**: "容器环境下如何保证测试的充分性？"
🔒 **Security**: "可以通过基础设施即代码实现测试环境标准化"

## 辩论收敛

### 正方最终立场
"容器化是现代化部署的必然趋势，短期的学习成本换来长期的架构优势"

### 反方最终立场  
"应该根据具体项目特点选择，不应盲目追求技术时髦"

## 综合裁决

### 关键评估维度

| 维度 | 容器化优势 | 传统部署优势 |
|------|----------|------------|
| 部署效率 | ★★★★★ | ★★★ |
| 性能表现 | ★★★ | ★★★★★ |
| 安全控制 | ★★★★ | ★★★ |
| 运维复杂度 | ★★★ | ★★★★ |
| 学习成本 | ★★ | ★★★★★ |

### 决策建议

**渐进式容器化策略**：
1. **无状态服务优先**：Web服务、API网关等先容器化
2. **有状态服务谨慎**：数据库等保持传统部署
3. **监控和回退**：建立完善的性能监控和快速回退机制

**成功条件**：
- 团队具备充足的容器化经验
- 有专门的平台团队支持  
- 业务可以接受短期的性能损失

**最终结论**：✅ **条件性推荐容器化**，需要 3-6 个月的渐进式迁移
```

## 高级辩论技巧

### 有效论证策略
1. **数据支撑**：使用具体的性能数据、案例研究
2. **场景分析**：针对具体业务场景进行论证
3. **权衡分析**：承认弱点，但强调核心优势
4. **未来预期**：考虑技术发展趋势的影响

### 常见辩论主题

#### 技术选型类
```bash
/role-debate architect vs performance "GraphQL vs REST API 设计选择"
/role-debate frontend vs mobile "原生应用 vs 混合应用开发策略"  
/role-debate security vs performance "同步认证 vs 异步认证机制"
```

#### 架构设计类  
```bash
/role-debate architect vs qa "单一数据库 vs 分库分表的数据架构"
/role-debate security vs performance "网关集中认证 vs 服务分散认证"
/role-debate architect vs mobile "BFF vs 统一API的移动端架构"
```

#### 工程实践类
```bash
/role-debate qa vs performance "全面测试覆盖 vs 快速迭代发布"
/role-debate security vs architect "强制HTTPS vs 兼容HTTP的渐进策略"  
/role-debate frontend vs performance "用户体验优化 vs 页面加载性能"
```

## 与其他命令的协作

### 辩论后的执行
```bash
# 1. 先进行辩论讨论  
/role-debate security vs performance "JWT vs Session 认证选择"

# 2. 基于辩论结果执行实现
/code 基于辩论结论实现JWT认证系统

# 3. 多角度验证实现
/multi-role security,performance --agent 验证JWT实现的安全性和性能表现
```

### 辩论前的准备
```bash  
# 1. 先了解现状
/ask 当前认证系统的架构和性能表现如何？

# 2. 进行对比辩论
/role-debate security vs performance "认证系统升级方案选择"

# 3. 深度思考决策
/ultrathink 基于辩论结果，制定认证系统升级的详细策略
```

## 实践建议

### 最佳使用场景
- ✅ **重要技术决策**：影响系统架构的关键选择
- ✅ **有争议的方案**：团队内部存在不同观点
- ✅ **成本权衡**：需要在多个目标间做平衡
- ✅ **风险评估**：高风险决策需要充分论证

### 辩论质量保证
- **充分准备**：提供具体的技术背景和约束条件
- **聚焦焦点**：避免过于宽泛的辩论主题
- **数据驱动**：基于具体数据而非主观判断
- **实用导向**：以可执行的解决方案为目标

### 注意事项
- **避免极端**：技术选择很少有绝对的对错
- **考虑约束**：团队能力、时间成本、业务需求都是重要因素
- **保持开放**：准备接受辩论过程中的观点转变
- **执行为重**：辩论的目的是做出更好的技术决策