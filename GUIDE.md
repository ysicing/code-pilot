# Claude Code 智能开发指南

> 完整使用指南 - 从入门到精通Claude Code工作流系统

## 📋 目录

- [系统安装](#系统安装)
- [快速上手](#快速上手)
- [核心工作流](#核心工作流)
- [命令详解](#命令详解)
- [专业角色](#专业角色)
- [扩展工具](#扩展工具)
- [最佳实践](#最佳实践)
- [故障排除](#故障排除)

## 🔧 系统安装

### 安装方式

```bash
# 方式1：用户级配置（推荐）
cd ~
git clone https://github.com/ysicing/code-pilot.git .claude

# 方式2：项目级配置
cd your-project  
git clone https://github.com/ysicing/code-pilot.git .claude

# 配置文件初始化
cd .claude
cp CLAUDE.md.example CLAUDE.md
# 编辑 CLAUDE.md 添加个人配置
```

### 配置说明

- **用户级配置**：适用于所有项目，配置一次即可
- **项目级配置**：针对特定项目的定制配置
- **CLAUDE.md**：包含个人偏好和项目特定规则

## ⚡ 一分钟极速上手

### 一键开始开发
```bash
# 快速开发 - 从需求到代码的完整流程
/requirements-pilot "实现用户注册功能，支持邮箱验证"

# 规范驱动 - 复杂功能的结构化设计
/kiro "设计一个支持多租户的SaaS系统"

# 企业级 - AI团队协作的完整开发流水线  
/bmad-pilot "构建高可用的微服务架构"

# 专业开发 - 六阶段精细控制
/zcf-workflow "开发在线教育平台"
```

系统会自动：
1. **智能分析需求** - 理解功能要点和技术约束
2. **生成实现方案** - 提供代码和架构建议
3. **质量保证** - 自动审查和优化
4. **测试验证** - 智能决定测试策略

## 🚀 核心工作流

### 🎯 选择适合的工作流

| 场景 | 推荐工作流 | 特点 |
|------|------------|------|
| **日常功能开发** | `/requirements-pilot` | 快速、自动化、质量门控 |
| **复杂系统设计** | `/kiro` | 结构化、文档化、3阶段 |
| **企业级项目** | `/bmad-pilot` | 团队协作、高质量、全流程 |
| **专业精细开发** | `/zcf-workflow` | 六阶段、质量把关、优化环节 |

### ⚡ Requirements-Pilot 快速开发

**最常用**，适合80%的开发场景：

```bash
/requirements-pilot "实现JWT认证中间件"
# ↓ 自动执行
# 需求分析 → 代码实现 → 质量检查 → 完成交付
```

**优势**：
- 端到端自动化
- 质量门控保证
- 快速迭代交付

### 📋 Kiro 规范驱动开发

**最结构化**，适合复杂功能规范：

```bash
/kiro "设计分布式缓存系统"
# ↓ 3阶段执行
# 需求文档 → 设计文档 → 任务分解 → 实施计划
```

**优势**：
- 需求明确化
- 设计文档完整
- 任务分解清晰

### 🏢 BMAD-Pilot 企业级协作

**最完整**，适合企业级项目：

```bash
/bmad-pilot "构建电商平台"
# ↓ AI团队协作
# 产品规划 → 架构设计 → 开发实现 → 质量保证 → 发布管理
```

**优势**：
- AI团队协作
- 完整质量体系
- 企业级标准

### 🔬 ZCF-Workflow 六阶段专业开发

**最精细**，适合专业开发者：

```bash
/zcf-workflow "开发在线教育平台"
# ↓ 六阶段流程
# 研究 → 构思 → 计划 → 执行 → 优化 → 评审
```

**优势**：
- 结构化六阶段
- 质量把关严格
- 包含优化环节
- 面向专业开发者

## 🛠️ 核心命令详解

### 📊 分析工具（4个）

#### `/ask` - 架构师咨询
```bash
/ask "如何设计高并发的秒杀系统？"
# 获得专业的架构建议和技术选型
```

#### `/ultrathink` - 深度分析
```bash
/ultrathink "Redis vs MongoDB 数据库选择"
# MECE结构化分析，全面对比
```

#### `/story-breakdown` - 功能分解
```bash
/story-breakdown "实现完整的用户管理系统"
# 将复杂功能分解为可执行的小任务
```

#### `/xplan` - 实施规划
```bash
/xplan "如何重构这个遗留系统？"
# 制定详细的实施计划和时间安排
```

### ⚙️ 开发工具（5个）

#### `/code` - 功能实现
```bash
/code "实现RSA加密解密功能"
# 直接编写高质量代码
```

#### `/refactor` - 代码重构
```bash
/refactor "这个类的职责太多，请帮我重构"
# 基于SOLID原则的安全重构
```

#### `/bugfix` - 修复缺陷
```bash
/bugfix "用户登录后Session丢失"
# 系统化的问题诊断和修复
```

#### `/debug` - 深度调试
```bash
/debug "内存泄漏问题，堆栈信息如下..."
# 深度分析和调试指导
```

#### `/optimize` - 性能优化
```bash
/optimize "API响应时间太慢，需要优化"
# 专业的性能分析和优化建议
```

### 🔍 质量保证（2个）

#### `/review` - 代码审查
```bash
/review "请审查这段API安全性"
# 多维度代码质量评估
```

#### `/test` - 测试策略
```bash
/test "为这个支付模块设计测试方案"
# 智能测试策略和实现
```

## 🎯 工作流选择指南

### 决策树
```
需求类型：
├── 快速功能开发 → /requirements-pilot
├── 复杂功能规范 → /kiro
├── 企业级项目 → /bmad-pilot
├── 专业精细开发 → /zcf-workflow
└── 技术决策分析 → /ultrathink
```

### 场景对比
| 维度 | Requirements-Pilot | Kiro | BMAD-Pilot | ZCF-Workflow |
|------|-------------------|------|------------|---------------|
| **速度** | ⚡⚡⚡⚡⚡ | ⚡⚡⚡ | ⚡⚡ | ⚡⚡⚡ |
| **文档** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **质量** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **复杂度** | 简单 | 中等 | 复杂 | 专业 |

## 👥 专业角色体系

### 🏗️ 核心专家团队（5个）

系统会根据问题类型自动调用合适的专家：

| 触发场景 | 自动调用 | 专业能力 |
|----------|----------|----------|
| 架构设计问题 | `architect` | 系统设计、技术决策 |
| 前端相关问题 | `frontend` | UI/UX、组件开发、构建配置 |
| 性能问题 | `performance` | 系统优化、瓶颈分析 |  
| 安全问题 | `security` | 威胁建模、防护策略 |
| 代码质量 | `reviewer` | 代码审查、最佳实践 |

### 🎯 手动调用专家

```bash
# 直接咨询架构师
"请architect分析这个分布式系统的设计"

# 请前端专家评估
"frontend专家帮我看看这个组件的可访问性"

# 安全专家评估
"security专家评估这个API的安全风险"
```

## 🧠 智能特性

### 自动判断和路由
- **问题理解** - 自动理解用户意图
- **复杂度判断** - 评估问题难度
- **工具选择** - 选择最适合的工具
- **智能执行** - 自动执行或询问确认

## 📝 使用技巧

### 💡 最佳实践

1. **从工作流开始**
   ```bash
   # ✅ 推荐：根据需求选择合适工作流
   /requirements-pilot "功能描述"  # 日常开发
   /kiro "复杂功能"               # 需要规范
   /bmad-pilot "企业项目"         # 团队协作
   /zcf-workflow "专业开发"       # 精细控制
   
   # ❌ 避免：手动拼接命令
   /ask → /code → /review → /test
   ```

2. **善用智能路由**
   ```bash
   # ✅ 让系统自动判断
   "帮我优化这个React组件的性能"  # 自动调用frontend专家
   
   # ❌ 手动指定可能不准确  
   /optimize "React组件优化"
   ```

3. **充分描述需求**
   ```bash
   # ✅ 详细描述
   /requirements-pilot "实现用户认证，支持JWT、OAuth2、记住登录状态"
   
   # ❌ 描述过于简单
   /requirements-pilot "登录功能"
   ```

### ⚠️ 常见误区

1. **过度分解** - 简单功能不需要story-breakdown
2. **工具选择** - 不确定时优先用工作流命令
3. **质量焦虑** - 相信系统的质量门控标准
4. **命令堆积** - 避免在一次对话中使用太多命令

## 🔧 扩展工具

### 按需使用的辅助工具

除了核心命令，还有丰富的专业扩展工具：

#### 📂 项目上下文管理
- `/context:create` - 创建项目初始上下文
- `/context:update` - 更新项目上下文
- `/context:prime` - 加载上下文到会话
- `/re-init` - 重新初始化架构文档

#### Git 智能工具
- `/git-cm` - 智能提交信息生成 + 完整Git操作
- `/git-msg` - 纯提交信息生成器

#### GitHub 协作工具
- `/gh/fix-issue` - GitHub Issue 修复工具
- `/gh/review-pr` - Pull Request 审查工具

#### 搜索与信息获取
- `/search-gemini` - Gemini网络搜索获取最新信息  
- `/ctx7` - 使用MCP的Context7搜索技术文档

#### 深度分析工具
- `/think-harder` - 复杂问题深度分析
- `/think-ultra` - 战略级深度思考
- `/multi-role` - 多专家并行分析
- `/role-debate` - 专业角色间深度辩论

#### 创新与辅助工具
- `/eureka` - 创新解决方案探索和风险评估
- `/translate` - 多语言翻译支持（支持术语管理）
- `/screenshot` - 智能屏幕截图分析（仅 macOS）
- `/session-review` - 会话分析与知识提取工具

#### 系统工具
- `/cc/create-command` - 创建新命令工具
- `/cc/reflection` - 会话反思工具
- `/cc/reflection-harder` - 深度反思工具
- `/cc/style-ai-writting` - AI 写作风格检查

### 🎯 工具选择决策树

```
遇到问题 → 是否为常见开发需求？
    ├─ 是 → 使用核心命令
    └─ 否 → 考虑扩展工具
    
需要开发功能 → 使用四大工作流
需要项目管理 → 使用上下文命令
需要专业建议 → 使用分析工具  
需要代码质量 → 使用质量保证工具
需要特殊功能 → 使用扩展工具
```

## 🚀 进阶使用

### 组合使用模式

```bash
# 复杂项目的完整流程
/kiro "设计用户管理系统"     # 先做规范设计
# ↓ 获得需求和设计文档后
/requirements-pilot "实现用户注册模块"  # 分模块实现
/requirements-pilot "实现用户认证模块"  
/requirements-pilot "实现权限管理模块"
```

### 迭代优化模式

```bash
# 第一轮：快速实现
/requirements-pilot "实现基础API"

# 第二轮：性能优化  
/optimize "优化API响应时间"

# 第三轮：安全加固
/review "审查API安全性"
```

---

## 🛠️ 故障排除

### 常见问题

#### Q: 系统没有自动触发合适的工具
**A**: 
- 检查问题描述是否足够具体
- 尝试使用后缀 `-u` 强制深度分析
- 直接指定工具：`/ask "你的问题"`

#### Q: 工作流执行中断了
**A**:
- 检查当前执行状态
- 使用 `/xplan` 制定继续执行计划
- 分步骤完成剩余任务

#### Q: 代码质量不满足要求  
**A**:
- 使用 `/review` 进行详细审查
- 根据审查建议进行改进
- 使用 `/refactor` 进行代码重构

#### Q: 不确定使用哪个工作流
**A**:
- 日常开发 → `/requirements-pilot`
- 需要文档 → `/kiro`
- 企业项目 → `/bmad-pilot`  
- 精细控制 → `/zcf-workflow`

### 性能优化建议

1. **充分描述需求** - 详细的需求描述有助于系统更准确地判断和执行
2. **合理使用工作流** - 优先使用四大工作流，而不是手动拼接命令
3. **善用智能路由** - 让系统自动判断通常比手动指定更准确
4. **适当使用扩展工具** - 核心命令覆盖不到的场景才使用扩展工具

---

🎯 **记住**：系统设计遵循KISS原则，核心命令覆盖90%开发场景。从简单开始，逐步深入！

📚 相关文档：
- [`README.md`](./README.md) - 项目概览
- [`BMAD-README.md`](./BMAD-README.md) - BMAD方法论指南
- [`CLAUDE.md.example`](./CLAUDE.md.example) - 配置示例
